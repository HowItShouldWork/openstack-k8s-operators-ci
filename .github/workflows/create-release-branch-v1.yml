# .github/workflows/create-release-branch-v1.yml
name: Create Feature Branches in Repos v1

on:
  # This workflow can be run manually from the Actions tab.
  workflow_dispatch:
    inputs:
      BRANCH_NAME:
        description: 'The name of the new feature/release branch to create, e.g. 18.0-fr3 .'
        required: true
        type: string
      NEW_VERSION:
        description: 'The new version to set in the Makefile on the main/source branch, e.g. 0.5 .'
        required: true
        type: string
      FORCE_BUMP_BRANCHES:
        description: 'The new list of branches for the force-bump-branches.yaml workflow, e.g. ["main", "18.0-fr3"] .'
        required: true
        type: string    
      DRY_RUN:
        description: 'Test Run! Run without pushing any changes. Disable to apply changes.'
        required: true
        type: boolean
        default: true

jobs:
  create-branches:
    runs-on: ubuntu-latest
    env:
      # Use current org as the ORG_NAME
      ORG_NAME: ${{ github.repository_owner }}
      # --- CONFIGURATION FROM INPUTS ---
      BRANCH_NAME: ${{ inputs.BRANCH_NAME }}
      NEW_VERSION: ${{ inputs.NEW_VERSION }}
      FORCE_BUMP_BRANCHES: ${{ inputs.FORCE_BUMP_BRANCHES }}
      DRY_RUN: ${{ inputs.DRY_RUN }}
      # 'The name of the version variable in the Makefile.'
      VERSION_VARIABLE: 'VERSION'
      # 'The name of the branch variable in the Makefile.'
      BRANCH_VARIABLE: 'BRANCH'
      # 'The name of the OpenStack K8s tag variable in the Makefile (for install_yamls).'
      OPENSTACK_K8S_TAG_VARIABLE: 'OPENSTACK_K8S_TAG'
      # 'The branch that must exist in a repo for it to be processed.'
      TRIGGER_BRANCH: 'olive'
      # 'The branch to create the new branch from.'
      SOURCE_BRANCH: 'main'    
    steps:
      - name: Generate a token from the GitHub App
        uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          # request an app token for the org instead of just the repo
          owner: ${{ env.ORG_NAME }}

      - name: Get GitHub App User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          echo "yq version $(yq --version) installed."

      - name: Validate Inputs
        run: |
          set -e
          if ! echo "${FORCE_BUMP_BRANCHES}" | yq -e 'tag == "!!seq"' >/dev/null 2>&1; then
            echo "Error: The 'FORCE_BUMP_BRANCHES' input "${FORCE_BUMP_BRANCHES}" is not a valid YAML array."
            echo "Please provide it in the format [\"item1\", \"item2\"]."
            exit 1
          fi
          
          if [[ -z "$BRANCH_NAME" ]] || [[ -z "$NEW_VERSION" ]]; then
            echo "Error: Required inputs BRANCH_NAME or NEW_VERSION were not provided."
            exit 1
          fi
          echo "Inputs are valid."          
          
      - name: Checkout code (for the workflow itself)
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          # Make sure the value of GITHUB_TOKEN will not be persisted in repo's config
          #persist-credentials: false        

      # ----------------------------------------------------------------
      # Step 1: Create the function library file
      # ----------------------------------------------------------------
      - name: Create Function Library
        run: |
          set -e

          # Use a heredoc to write a multi-line script file.
          # This file will contain all your reusable functions.
          cat <<'EOF' > workflow_functions.sh
          #!/bin/bash

          # A function to handle committing and pushing changes.
          # Arguments: 1: Commit Message, 2: File(s) to add, 3: Branch to push
          commit_and_push() {
            local commit_message="$1"
            local files_to_add="$2"
            local branch_to_push="$3"

            if ! git diff --quiet -- $files_to_add; then
              echo "Showing changes for branch '${branch_to_push}':"
              git diff -- $files_to_add
              if [ "$DRY_RUN" = "true" ]; then
                echo "DRY RUN: Commit '${commit_message}' not created for branch '${branch_to_push}'."
              else
                git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
                git config --global user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'
                git add $files_to_add
                git commit -m "$commit_message"
                echo "Pushing changes to ${branch_to_push}..."
                git push origin ${branch_to_push}
              fi
            else
              echo "No changes detected in '${files_to_add}'. Nothing to commit."
            fi
          }

          # Updates a value in a YAML file, automatically detecting the type of the existing node.
          # Arguments: 1: File Path, 2: YQ Target Path, 3: New Value
          update_yaml_value() {
            local file_path="$1"
            local yq_path="$2"
            local new_value="$3"

            if [ ! -f "${file_path}" ]; then echo "Error: File '${file_path}' not found. Skipping."; return; fi
            if ! yq -e "(${yq_path}) != null" "${file_path}" >/dev/null; then echo "Error: Path '${yq_path}' not found in '${file_path}'."; return; fi
            
            # Get the tag of the existing node to determine its type
            local current_tag
            current_tag=$(yq e "(${yq_path}) | tag" "${file_path}")

            if [ "$current_tag" = "!!seq" ]; then
              # It's an array, treat new value as a literal so yq can parse it
              echo "Path '${yq_path}' is an array. Replacing with new value: ${new_value}"
              yq -i "${yq_path} = ${new_value}" "${file_path}"
            else
              # It's a scalar (string, int, etc.), treat new value as a string
              echo "Path '${yq_path}' is a scalar. Updating from '${current_value}' to '${new_value}'..."
              yq -i "${yq_path} = \"${new_value}\"" "${file_path}"
            fi
          } 

          # Reads a value from a YAML file using a yq path.
          # Arguments: 1: File Path, 2: YQ Target Path
          get_yaml_value() {
            local file_path="$1"
            local yq_path="$2"

            # Check if the file exists
            if [ ! -f "${file_path}" ]; then echo "Error: File '${file_path}' not found. Skipping." >&2; return; fi
            if ! yq -e "(${yq_path}) != null" "${file_path}" >/dev/null; then echo "Error: Path '${yq_path}' not found in '${file_path}'."; return; fi

            # If checks pass, get and echo the value
            yq e "${yq_path}" "${file_path}"
          }
          EOF

      - name: Create release branches and update the release branch
        env:
          # Use the token generated from the GitHub App
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          # GH_TOKEN: ${{ secrets.ORG_ADMIN_PAT }}
        run: |
          set -ex # Exit immediately if a command exits with a non-zero status.
          source ./workflow_functions.sh
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "!!! --- Running in DRY RUN mode. No changes will be pushed. --- !!!"
          fi
          
          echo "Running with the following configuration:"
          echo "Organization: ${ORG_NAME}"
          echo "Feature Branch Name: ${BRANCH_NAME}"
          echo "New Version on main: ${NEW_VERSION}"
          echo "New FORCE_BUMP_BRANCHES: ${FORCE_BUMP_BRANCHES}"
          echo "Trigger Branch: ${TRIGGER_BRANCH}"
          echo "Source Branch: ${SOURCE_BRANCH}"
          echo "-------------------------------------------"
          
          echo "Searching for repositories in organization '${ORG_NAME}'..."
          repos=$(gh repo list $ORG_NAME --limit 1000 --json name --jq '.[] | .name')

          if [ -z "$repos" ]; then
            echo "No repositories found in the organization or permissions are missing."
            exit 1
          fi

          created_repos=""

          for repo_name in $repos; do
            echo "--- Checking REPOSITORY: ${repo_name} ---"

            if [[ "$repo_name" == "rabbitmq-cluster-operator" ]]; then 
              continue
            fi

            if gh api "repos/${ORG_NAME}/${repo_name}/branches/${TRIGGER_BRANCH}" >/dev/null 2>&1; then
              echo "✅ Trigger branch '${TRIGGER_BRANCH}' found in ${repo_name}."

              TEMP_DIR=$(mktemp -d)
              echo "Cloning repository into ${TEMP_DIR}..."
              git clone "https://x-access-token:${GH_TOKEN}@github.com/${ORG_NAME}/${repo_name}.git" "$TEMP_DIR"
              
              cd "$TEMP_DIR"

              if ! git show-ref --verify --quiet "refs/remotes/origin/${SOURCE_BRANCH}"; then
                echo "⚠️ Source branch '${SOURCE_BRANCH}' does not exist in ${repo_name}. Skipping."
                cd .. && rm -rf "$TEMP_DIR"
                continue
              fi

              if git show-ref --verify --quiet "refs/remotes/origin/${BRANCH_NAME}"; then
                echo "ℹ️ Branch '${BRANCH_NAME}' already exists in ${repo_name}. Skipping this repository."
                cd .. && rm -rf "$TEMP_DIR"
                continue
              fi
              
              echo "Creating branch '${BRANCH_NAME}' from '${SOURCE_BRANCH}'..."
              git checkout ${SOURCE_BRANCH}
              git checkout -b ${BRANCH_NAME}

              if [ -f "Makefile" ]; then
                echo "Makefile found. Checking for variables to update on new branch..."
                if grep -qE "^${BRANCH_VARIABLE}\s*(\?=|=)" Makefile; then
                  sed -i -E "s/^(${BRANCH_VARIABLE}\s*(\?=|=)\s*).*/\1${BRANCH_NAME}/" Makefile
                fi
                if [[ "$repo_name" == "install_yamls" ]]; then
                  if grep -qE "^${OPENSTACK_K8S_TAG_VARIABLE}\s*(\?=|=)" Makefile; then
                    sed -i -E "s/^((${OPENSTACK_K8S_TAG_VARIABLE})\s*(\?=|=)\s*).*/\1${BRANCH_NAME}-latest/" Makefile
                  fi
                fi
                commit_and_push "[${BRANCH_NAME}] Update Makefile for ${BRANCH_NAME}" "Makefile" "${BRANCH_NAME}"
              else
                echo "No Makefile found. No changes will be committed to new branch."
              fi

              created_repos+="- ${repo_name}\n"

              cd .. && rm -rf "$TEMP_DIR"
            else
              echo "❌ Trigger branch '${TRIGGER_BRANCH}' not found in ${repo_name}. Skipping."
            fi
          done

          echo "-------------------------------------------"
          if [ "$DRY_RUN" = "true" ]; then
            echo "Summary of repos where the new branch ${BRANCH_NAME} would have been created (DRY RUN):"
          else
            echo "Summary of repos where the new branch ${BRANCH_NAME} was created:"
          fi

          if [[ -n "$created_repos" ]]; then
            echo -e "$created_repos"
          else
            echo "No new branches were created."
          fi

      - name: Update openstack-operator main branch
        env:
          # Use the token generated from the GitHub App
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -ex # Exit immediately if a command exits with a non-zero status.
          source ./workflow_functions.sh
          
          echo "--- Checking REPOSITORY: openstack-k8s-operators-ci ---"
          TEMP_DIR=$(mktemp -d)
          echo "Cloning repository into ${TEMP_DIR}..."
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${ORG_NAME}/openstack-operator.git" "$TEMP_DIR"
          cd "$TEMP_DIR"

          # Update workflows on the main branch
          git checkout main
          git pull origin main

          # change to the Makefile
          if [ -f "Makefile" ]; then
            FULL_MAKEFILE_VERSION="${NEW_VERSION}.0"
            if grep -qE "^${VERSION_VARIABLE}\s*(:=|\?=|=)" Makefile; then
              sed -i -E "s/^(${VERSION_VARIABLE}\s*(:=|\?=|=)).*/\1 ${FULL_MAKEFILE_VERSION}/" Makefile
              commit_and_push "Bump version to ${FULL_MAKEFILE_VERSION}" "Makefile" "${SOURCE_BRANCH}"
            else
              echo "Variable '${VERSION_VARIABLE}' not found. No changes pushed to ${SOURCE_BRANCH}."
            fi
          else
            echo "No Makefile found. No changes pushed to ${SOURCE_BRANCH}."
          fi

          # change to hack/fake_minor_update.sh
          if [ -f "hack/fake_minor_update.sh" ]; then
            if grep -qE "^${VERSION_VARIABLE}=" hack/fake_minor_update.sh; then
              sed -i -E "s/^(${VERSION_VARIABLE}=).*/\1${NEW_VERSION}/" hack/fake_minor_update.sh
              commit_and_push "Bump version to ${NEW_VERSION}" "hack/fake_minor_update.sh" "${SOURCE_BRANCH}"
            else
              echo "Variable '${VERSION_VARIABLE}' not found. No changes pushed to ${SOURCE_BRANCH}."
            fi
          else
            echo "No hack/fake_minor_update.sh found. No changes pushed to ${SOURCE_BRANCH}."
          fi

          # changes to .github/workflows/catalog-openstack-operator-upgrades.yaml
          WORKFLOW_FILE=".github/workflows/catalog-openstack-operator-upgrades.yaml"
          if [ -f "${WORKFLOW_FILE}" ]; then
            # 1. Find the index of the step to update
            index=$(yq '.jobs.build-catalog.steps | to_entries | .[] | select(.value.name == "Create the catalog index") | .key' ${WORKFLOW_FILE})
            
            # 2. Check if an index was found
            if [ -z "$index" ]; then
              echo "Step 'Create the catalog index' not found."
              exit 1
            fi

            echo "Found 'Create the catalog index' step at index: $index"
            CURRENT_VERSION=$(get_yaml_value "${WORKFLOW_FILE}" ".jobs.build-catalog.steps[$index].env.MAIN_VERSION")
            FULL_NEW_VERSION="${NEW_VERSION}.0"
            # 3. Use the index to update the 'image' field in place (-i)
            update_yaml_value "${WORKFLOW_FILE}" ".jobs.build-catalog.steps[$index].env.MAIN_VERSION" "${FULL_NEW_VERSION}"
            update_yaml_value "${WORKFLOW_FILE}" ".jobs.build-catalog.steps[$index].env.FEATURE_RELEASE_VERSION" "${CURRENT_VERSION}"
            update_yaml_value "${WORKFLOW_FILE}" ".jobs.build-catalog.steps[$index].env.FEATURE_RELEASE_BRANCH" "${BRANCH_NAME}"
            commit_and_push "Bump version in ${WORKFLOW_FILE} to ${FULL_NEW_VERSION}" "${WORKFLOW_FILE}" "${SOURCE_BRANCH}"
          else
            echo "No ${WORKFLOW_FILE} found. No changes pushed to ${SOURCE_BRANCH}."
          fi            

          cd .. && rm -rf "$TEMP_DIR"          

      - name: Update openstack-k8s-operators-ci workflows
        env:
          # Use the token generated from the GitHub App
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          source ./workflow_functions.sh

          echo "--- Checking REPOSITORY: openstack-k8s-operators-ci ---"
          TEMP_DIR=$(mktemp -d)
          echo "Cloning repository into ${TEMP_DIR}..."
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${ORG_NAME}/openstack-k8s-operators-ci.git" "$TEMP_DIR"
          cd "$TEMP_DIR"

          # Update workflows on the main branch
          git checkout main
          git pull origin main

          update_yaml_value ".github/workflows/release-branch-sync.yaml" ".on.workflow_call.inputs.source_branch.default" "${BRANCH_NAME}"
          update_yaml_value ".github/workflows/force-bump-branches.yaml" ".jobs.trigger-jobs.strategy.matrix.branch" "${FORCE_BUMP_BRANCHES}"

          # Commit and push changes if any were made
          commit_and_push "ci: Update workflow defaults for ${BRANCH_NAME}" ".github/workflows/" "${BRANCH_NAME}"

          cd .. && rm -rf "$TEMP_DIR"
          echo "Workflow finished."

  # 1. Add a new job specifically for logging and validation
  log-the-tag:
    runs-on: ubuntu-latest
    outputs:
      # Define an output to pass the tag to the next job
      tag_to_use: ${{ steps.generate_tag.outputs.new_tag }}
    steps:
      - name: Generate and Log the Tag
        id: generate_tag
        run: |
          # Construct the tag value
          TAG_VALUE="${{ inputs.BRANCH_NAME }}-latest"
          
          # Log it for debugging
          echo "Constructed new_tag value is: '${TAG_VALUE}'"

          # Set the value as an output for the next job
          echo "new_tag=${TAG_VALUE}" >> $GITHUB_OUTPUT

  # 2. Update your existing job to use the output from the logging job
  retag-and-push-rabbitmq-cluster-operator-index:
    # This job now depends on the new logging job
    needs: [create-branches, log-the-tag]
    uses: ./.github/workflows/rabbitmq-cluster-operator-index-feature-tag.yaml
    with:
      # Use the output from the 'log-the-tag' job
      new_tag: ${{ needs.log-the-tag.outputs.new_tag }}
    secrets:
      # Pass secrets as before
      IMAGENAMESPACE: ${{ secrets.IMAGENAMESPACE }}
      QUAY_USERNAME: ${{ secrets.QUAY_USERNAME }}
      QUAY_PASSWORD: ${{ secrets.QUAY_PASSWORD }}      
